#!/usr/bin/env python

import re
import os.path
import glob
import optparse
import sys


Global = {}
Global['ppout'] = []
Global['spath'] = ['.']
Global['ds'] = {}
Global['ds']['ifiles'] = {}
Global['ds']['ifiles']['visited'] = {} # for stopping reincluding the files multiple times
Global['ds']['ifiles']['active'] = {} # for loop detection
Global['ds']['ifiles']['active_arr'] = [] # for loop detection

def display(msg):
  sys.stderr.write(msg + "\n")

def info(msg):
  display("INFO:" + msg)

def warn(msg):
  display("WARN:" + msg)
  
def error(msg):
  display("ERROR:" + msg)

def fatal(msg):
  display("FATAL:" + msg)
  sys.exit(-1)

def parse_args():
  parser = optparse.OptionParser("usage: %prog [options] [file]\n DML preprocessor to include files . Works similar as C preprocessor\n")
  parser.add_option("-o", "--output", action="store", type="string")
  parser.add_option("-I", "--include", action="append", type="string")

  (options, args) = parser.parse_args()
  #check the mandatory options and args
  if not options.output:
    fatal("You must specify the the -o or --output options") 
  if len(args) < 1:
    parser.error("incorrect number of arguments")

  # update the globals
  if (options.include):
    Global['spath'] = Global['spath'] + options.include
  Global['options'] = options
  Global['args'] = args
  
  return (options, args)


def find_files(pat):
 files = []
 if (re.match(r'^/', pat)):  # absolute path
   files = files + glob.glob(pat)
 elif (re.match(r'.*', pat)): # relative path to the search path
   for sp in Global['spath']:
     apath_pat = os.path.abspath(os.path.join(sp, pat))
     gfiles = glob.glob(apath_pat)
     if (len(gfiles) != 0):
       files = files + gfiles
       found = True
       break
 else:
   pass
 return files


def preprocess_file(infile):
  infile = os.path.abspath(infile)
  # for loop detection
  if (infile in Global['ds']['ifiles']['active']):
    emsg = ""
    tab = "   "
    for f in  Global['ds']['ifiles']['active_arr']:
      emsg += tab + f + " includes " + "\n"
      tab += "   "
    emsg += tab + infile
    fatal("The following Include loop detected \n" + emsg)
  else:
    Global['ds']['ifiles']['active'][infile] = 1
    Global['ds']['ifiles']['active_arr'].append(infile)

  if (infile in Global['ds']['ifiles']['visited']):  # for stopping reincluding the files multiple times
    warn("File:" + infile + " has already been included. skipping it")
    return

  with open(infile, "r") as ins:
    array = []
    for line in ins:
      array.append(line)
      Global['ppout'].append(line,)
      m = re.match('^#include\s+"(.*)"\s*$', line)
      if (m):
        ipats = m.groups()
        sline = line.strip()
        for ipat in ipats:
          files = find_files(ipat)
          ffound = False
          for f in files:
            if (f in Global['ds']['ifiles']['visited']):  # for stopping reincluding the files multiple times
              warn("File:" + f + " has already been included. skipping it")
              return
            else:
              Global['ppout'].append("#dmlpp autogenerated BEGIN including '"+sline+"'\n");
              preprocess_file(f) 
              Global['ppout'].append("#dmlpp autogenerated END including '"+sline+"'\n");
              ffound = True
          if (not ffound):
            fatal("Can't find the include pattern file " + line + " in the parent " + infile)

  Global['ds']['ifiles']['active'].pop(infile, None) # make infile non active
  Global['ds']['ifiles']['active_arr'].pop() # pop up the active arr
  Global['ds']['ifiles']['visited'][infile] = 1 # for stopping reincluding the files multiple times

def write_output(out_arr, output):
  if (output):
    if (os.path.isfile(output)):
      fatal("Output file already exists '{output}' ".format(output=output))
    with open(output, "w") as ons:
      for line in Global['ppout']:
        ons.write(line)
  else:
    for line in out_arr:
      sys.stdout.write(line)
    


(options, args) = parse_args()
preprocess_file(args[0])
write_output(Global['ppout'], Global['options'].output)

